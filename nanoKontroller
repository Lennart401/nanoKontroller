#!/usr/bin/python

import argparse
import time
import mido
import logging
from enum import Enum
from evdev import uinput, ecodes as e
from pulsectl import Pulse

class nano_keys(Enum):
	TRACK_PREV = 58
	TRACK_NEXT = 59
	CYCLE = 46
	MARKER_SET = 60
	MARKER_PREV = 61
	MARKER_NEXT = 62
	PREV = 43
	NEXT = 44
	STOP = 42
	PLAY = 41
	RECORD = 45
	PARAM1_SOLO = 32
	PARAM2_SOLO = 33
	PARAM3_SOLO = 34
	PARAM4_SOLO = 35
	PARAM5_SOLO = 36
	PARAM6_SOLO = 37
	PARAM7_SOLO = 38
	PARAM8_SOLO = 39
	PARAM1_MUTE = 48
	PARAM2_MUTE = 49
	PARAM3_MUTE = 50
	PARAM4_MUTE = 51
	PARAM5_MUTE = 52
	PARAM6_MUTE = 53
	PARAM7_MUTE = 54
	PARAM8_MUTE = 55
	PARAM1_RECORD = 64
	PARAM2_RECORD = 65
	PARAM3_RECORD = 66
	PARAM4_RECORD = 67
	PARAM5_RECORD = 68
	PARAM6_RECORD = 69
	PARAM7_RECORD = 70
	PARAM8_RECORD = 71
	PARAM1_SLIDER = 0
	PARAM2_SLIDER = 1
	PARAM3_SLIDER = 2
	PARAM4_SLIDER = 3
	PARAM5_SLIDER = 4
	PARAM6_SLIDER = 5
	PARAM7_SLIDER = 6
	PARAM8_SLIDER = 7
	PARAM1_KNOB = 16
	PARAM2_KNOB = 17
	PARAM3_KNOB = 18
	PARAM4_KNOB = 19
	PARAM5_KNOB = 20
	PARAM6_KNOB = 21
	PARAM7_KNOB = 22
	PARAM8_KNOB = 23
	
	led_support = [
		TRACK_PREV,
		TRACK_NEXT,
		CYCLE,
		MARKER_SET,
		MARKER_PREV,
		MARKER_NEXT,
		PREV,
		NEXT,
		STOP,
		PLAY,
		RECORD,
		PARAM1_SOLO,
		PARAM2_SOLO,
		PARAM3_SOLO,
		PARAM4_SOLO,
		PARAM5_SOLO,
		PARAM6_SOLO,
		PARAM7_SOLO,
		PARAM8_SOLO,
		PARAM1_MUTE,
		PARAM2_MUTE,
		PARAM3_MUTE,
		PARAM4_MUTE,
		PARAM5_MUTE,
		PARAM6_MUTE,
		PARAM7_MUTE,
		PARAM8_MUTE,
		PARAM1_RECORD,
		PARAM2_RECORD,
		PARAM3_RECORD,
		PARAM4_RECORD,
		PARAM5_RECORD,
		PARAM6_RECORD,
		PARAM7_RECORD,
		PARAM8_RECORD		
	]

# Prefined direct button to keyboard mappings
default_keymap = [
	["PLAY", "KEY_PLAYPAUSE"],
	["PREV", "KEY_PREVIOUSSONG"],
	["NEXT", "KEY_NEXTSONG"],
	["STOP", "KEY_STOPCD"],
	["RECORD", "KEY_RECORD"]
]


def generate_keymap(key_config):
	"""Generate a key mapping from the supplied config
	
	key_config should be a list nanoKONTROL2 keys and evdev events they
	should map to directly.
	"""
	
	keymap = {}
	
	for key_to_map in key_config:
		try:
			keymap[nano_keys[key_to_map[0]].value] = e.ecodes[key_to_map[1]]
		except:
			logging.error('generate_keymap: Failed to map key {} to {}'.format(key_to_map[0], key_to_map[1]))
	
	return keymap

def getSinkByName(pactl, name):
	"""Return a PulseAudio output sink object, searching for it by name"""
	for sink in pactl.sink_list():
		logging.debug('getSinkByName: saw sink named {}'.format(sink.name))
		if sink.name == name:
			logging.debug('getSinkByName: found the sink required, {}'.format(sink.name))
			return sink
	
	return None


def getSourceByName(pactl, name):
	"""Return a PulseAudio input source object, searching for it by name"""
	for source in pactl.source_list():
		logging.debug('getSourceByanem: saw source named {}'.format(source.name))
		if source.name == name:
			logging.debug('getSourceByName: found the source required, {}'.format(source.name))
			return source
	
	return None


def setLed(port, led, value):
	"""Set any LED on the nanoKONTROL2"""
	logging.debug('setLed: led={}, value={}'.format(led, value))
	port.send(mido.Message('control_change', control=led, value=value))


def setAllLeds(port, value):
	"""Set all LEDs on the nanoKONTROL2"""
	for led in range(32, 72):
		setLed(port, led, value)

	

# Parse command line args, of which we only care about one - debug mode
parser = argparse.ArgumentParser()
parser.add_argument('--debug', action='store_true')
args = parser.parse_args()

# Setup logging
if args.debug:
	logging.basicConfig(format='%(asctime)-15s %(levelname)-8s %(message)s', level=logging.DEBUG)
else:
	logging.basicConfig(format='%(asctime)-15s %(levelname)-8s %(message)s', level=logging.INFO)
	
logging.debug('Starting up')

# Generate the keymap for simple button mappings
keymap = generate_keymap(default_keymap)

# Open the uinput object for sending fake keypresses
ui = uinput.UInput()

# Open the MIDI objects for the nanKONTROL2 device
inport = mido.open_input('nanoKONTROL2 MIDI 1')
outport = mido.open_output('nanoKONTROL2 MIDI 1')

# Open PulseAudio for volume control
pactl = Pulse('nanoKontroller')

# Get the PulseAudio sinks and sources for the main audio device and the
# headset device
outputSink = getSinkByName(pactl, 'alsa_output.usb-0d8c_Generic_USB_Audio_Device-00.iec958-stereo')
inputSink = getSinkByName(pactl, 'alsa_output.usb-Plantronics_SupraPlus_Wideband_USB-00.analog-stereo')
inputSource = getSourceByName(pactl, 'alsa_input.usb-Plantronics_SupraPlus_Wideband_USB-00.analog-mono')

# Set the current muted state. We're assuming that nanoKontroller will
# start before anything is muted ...
muted = 0
inputMuted = 0

# Print warnings if we couldn't open any of our PA sinks or sources
if outputSink == None:
	logging.error('Failed to open output sink')

if inputSink == None:
	logging.error('Failed to open input sink')

if inputSource == None:
	logging.error('Failed to open input source')

# Reset all LEDs
setAllLeds(outport, 0)

# Main loop - process MIDI messages from the nanoKONTROL2 device as
# they arrive
for msg in inport:
	if msg.type == 'control_change':
		logging.debug('Control change message for key {}, value {}'.format(msg.control, msg.value))
		
		# Fake keyboard inputs for mapped buttons defined in keymap
		if msg.control in keymap.keys():
			logging.debug('Handling control message for key {}, value {}'.format(msg.control, msg.value))
			ui.write(e.EV_KEY, keymap[msg.control], msg.value/126)
			setLed(outport, msg.control, msg.value)
			ui.syn()
		
		# Set the volume of the speaker
		elif msg.control == 0:
			logging.debug('Handling speaker volume control event, value {}'.format(msg.value))
			pactl.volume_set_all_chans(outputSink, (msg.value / 127.0))
		
		# Set the volume of the headset. Note that this can exceed 100%
		# so that PA will amplify the incoming audio of quiet VoIP
		# calls (msg.value is in the range 0-127, so dividing by 85
		# means max volume will actually be 150%)
		elif msg.control == 1:
			logging.debug('Handling headset volume control event, value {}'.format(msg.value))
			if inputSink != None:
				pactl.volume_set_all_chans(inputSink, (msg.value / 85.0))
		
		# Handle the speaker mute control
		elif msg.control == 48:
			if msg.value == 127:
				logging.debug('Handling speaker volume mute toggle')
				if muted == 0:
					muted = 1
				else:
					muted = 0
				if outputSink != None:
					pactl.mute(outputSink, muted)
				setLed(outport, msg.control, muted * 127)
		
		# Handle the headset mute control which affects the microphone,
		# rather than the audio
		elif msg.control == 49:
			if msg.value == 127:
				logging.debug('Handling headset volume mute toggle')
				if inputMuted == 0:
					inputMuted = 1
				else:
					inputMuted = 0
				if inputSource != None:
					pactl.mute(inputSource, inputMuted)
				setLed(outport, msg.control, inputMuted * 127)
		
		# Other inputs end up here - all other buttons, sliders and
		# dials will log their control ID and value
		else:
			logging.debug('Unhandled control change: {}'.format(msg))
	else:
		logging.debug('Unhandled message: {}'.format(msg))

